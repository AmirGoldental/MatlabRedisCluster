function [task_keys, tasks] = new_task(commands, varargin)
commands = reshape(commands,1,[]);
char_varargin = cellfun(@(x) char(x), varargin, 'UniformOutput', false);

tasks = cell(0);
if ~iscell(commands)
    commands = {commands};
end

if any(strcmpi('addpath', char_varargin))
    path2add = char_varargin{find(strcmpi('addpath', char_varargin), 1) + 1};
else
    path2add = 'None';
end

for i = 1:length(commands)
    command = char(commands{i});
    task = struct();
    task.command = command;
    task.created_by = [getenv('COMPUTERNAME'), '/', getenv('USERNAME')];
    task.created_on = datetime();
    task.path2add = path2add;
    tasks{i} = task;
end


if any(strcmpi('dependencies', char_varargin))
    dependencies = varargin{find(strcmpi('dependencies', char_varargin), 1) + 1};
    if ~iscell(dependencies)
        dependencies = {dependencies};
    end
    dependencies = char(join(dependencies(:)', ' '));
else
    dependencies = '';
end

lua_add_task = char(strcat("""", ...
    "local task_id = redis.call('INCR','tasks_count'); ", ...
    "local task_key = 'task:' .. task_id; ", ...
    "local task_status; ", ...
    "for idx=1,#ARGV,1 do ", ...
        "if redis.call('HGET', ARGV[idx], 'status') == 'pending' or redis.call('HGET', ARGV[idx], 'status') == 'pre_pending' or redis.call('HGET', ARGV[idx], 'status') == 'ongoing' then ", ...
            "redis.call('LPUSH', task_key .. ':dependencies', ARGV[idx]); ", ...
            "redis.call('LPUSH', ARGV[idx] .. ':prior_to', task_key); ", ...
        "end; ", ...
    "end; ", ...
    "if redis.call('LLEN', task_key .. ':dependencies') == 0 then ",...
        "redis.call('RPUSH', 'pending_tasks', task_key); ", ...
        "task_status = 'pending'; ", ...
    "else ",...
        "redis.call('RPUSH', 'pre_pending_tasks', task_key); ", ...
        "task_status = 'pre_pending'; ", ...
    "end;", ...  
    "redis.call('HMSET', task_key, ", ...
        "'key', task_key, ", ...
        "'id', tostring(task_id), ", ...
        "'command', KEYS[1], ", ...
        "'created_by', KEYS[2], ", ...
        "'created_on', KEYS[3], ", ...
        "'path2add', KEYS[4], ", ...
        "'status', task_status); ", ...
    "return task_key", ...
    """ 4"));

redis_add_task = @(task) ['eval ' lua_add_task ...
    ' ' str_to_redis_str(task.command) ...
    ' ' str_to_redis_str(task.created_by) ...
    ' ' str_to_redis_str(task.created_on) ...
    ' ' str_to_redis_str(task.path2add) ...
    ' ' dependencies];
cmds = cellfun(redis_add_task, tasks, 'UniformOutput', false);
task_keys = mrc.redis_cmd(cmds);

for task_idx = 1:numel(tasks)
    tasks{task_idx}.key = task_keys{task_idx};
end

if any(strcmpi('wait', varargin))
    mrc.wait(task_keys);
end
    
if length(tasks)==1
    tasks = tasks{1};
end

end

